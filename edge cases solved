import requests
import re
import json
from typing import List, Dict, Any

def generate_chart_suggestions(question: str, all_results: List[Dict[str, Any]]) -> Dict[str, Any]:
    description_section = ""
    for result in all_results:
        db = result["db"]
        rows = result["results"]
        if not rows:
            continue
        sample_row = rows[0]
        description_section += f"-- {db} columns: {list(sample_row.keys())}\n"

    prompt = f"""
You are a data visualization assistant helping unify result sets from multiple databases.

The user question is:
{question}

Below are result columns returned from each database (not SQL):

{description_section}

Your tasks:
1. Understand the semantic meaning of each column in each DB.
2. Suggest the most appropriate chart type for the user question and the available columns.
3. For bar/line/scatter, return x_axis and y_axis.
4. For pie/donut, return labels and values.
5. Always map actual column names to a standard schema.

Example Output:
{{
  "chart_type": "pie",
  "labels": {{
    "standard": "category",
    "swift": "category_name"
  }},
  "values": {{
    "standard": "count",
    "swift": "product_count"
  }}
}}

OR

{{
  "chart_type": "bar",
  "x_axis": {{
    "standard": "product",
    "eon": "product",
    "swift": "item"
  }},
  "y_axis": {{
    "standard": "sales",
    "eon": "order_count",
    "swift": "sold_units"
  }},
  "group_by": "database"
}}
"""

    payload = {"contents": [{"parts": [{"text": prompt}]}]}
    headers = {"Content-Type": "application/json"}
    response = requests.post(GEMINI_URL, headers=headers, json=payload)
    response.raise_for_status()
    data = response.json()

    charts_json = None
    try:
        if "candidates" in data and data["candidates"]:
            candidate = data["candidates"][0]
            content = candidate.get("content")
            if isinstance(content, dict) and "parts" in content:
                charts_json = content["parts"][0].get("text", "")
            elif isinstance(content, str):
                charts_json = content
    except Exception as e:
        print("❌ Unexpected Gemini response structure.")
        print(json.dumps(data, indent=2))
        raise e

    if charts_json:
        try:
            match = re.search(r"```json\s*(\{.*?\})\s*```", charts_json, re.DOTALL)
            if match:
                parsed = json.loads(match.group(1))
            else:
                fallback_match = re.search(r"(\{.*?\})", charts_json, re.DOTALL)
                parsed = json.loads(fallback_match.group(1)) if fallback_match else {}

            if "chart_type" not in parsed:
                return {}
            return parsed

        except json.JSONDecodeError as e:
            print("❌ Failed to parse chart config.")
            print(repr(charts_json))
            raise e

    return {}



import pandas as pd
from typing import List, Dict, Any

def normalize_and_merge_results(all_results: List[Dict[str, Any]], chart_mapping: Dict[str, Any]) -> pd.DataFrame:
    frames = []
    chart_type = chart_mapping.get("chart_type", "").lower()

    # Identify required standard fields
    if chart_type in {"pie", "donut"}:
        label_std = chart_mapping.get("labels", {}).get("standard")
        value_std = chart_mapping.get("values", {}).get("standard")
        if not label_std or not value_std:
            return pd.DataFrame()
    else:
        x_std = chart_mapping.get("x_axis", {}).get("standard")
        y_std = chart_mapping.get("y_axis", {}).get("standard")
        if not x_std or not y_std:
            return pd.DataFrame()

    for result in all_results:
        db_key = result["db"]
        rows = result["results"]
        if not rows:
            continue

        df = pd.DataFrame(rows)

        if chart_type in {"pie", "donut"}:
            label_map = chart_mapping.get("labels", {}).get(db_key)
            value_map = chart_mapping.get("values", {}).get(db_key)

            if not label_map or label_map not in df.columns:
                continue

            df = df.rename(columns={label_map: label_std})
            if not value_map or value_map not in df.columns:
                df[value_std] = 1
            else:
                df = df.rename(columns={value_map: value_std})

            df["database"] = db_key  # ✅ Added for consistency
            frames.append(df[[label_std, value_std, "database"]])

        else:
            x_map = chart_mapping.get("x_axis", {}).get(db_key)
            y_map = chart_mapping.get("y_axis", {}).get(db_key)

            if not x_map or x_map not in df.columns:
                continue

            df = df.rename(columns={x_map: x_std})
            if not y_map or y_map not in df.columns:
                df[y_std] = 1
            else:
                df = df.rename(columns={y_map: y_std})

            df["database"] = db_key
            frames.append(df[[x_std, y_std, "database"]])

    return pd.concat(frames, ignore_index=True) if frames else pd.DataFrame()




import plotly.graph_objects as go

def fallback_table(df: pd.DataFrame) -> go.Figure:
    return go.Figure(data=[go.Table(
        header=dict(values=list(df.columns)),
        cells=dict(values=[df[col] for col in df.columns])
    )])



import plotly.express as px

def plot_charts_from_config(df: pd.DataFrame, chart_config: Dict[str, Any]) -> List[Any]:
    figs = []
    chart_type = chart_config.get("chart_type", "bar").lower()

    if df.empty or not chart_type:
        return [fallback_table(df)]

    try:
        if chart_type in {"bar", "line", "scatter", "area"}:
            x = chart_config.get("x_axis", {}).get("standard")
            y = chart_config.get("y_axis", {}).get("standard")
            color = chart_config.get("group_by", "database")
            if not x or not y:
                return [fallback_table(df)]
            plot_fn = getattr(px, chart_type, None)
            if callable(plot_fn):
                fig = plot_fn(df, x=x, y=y, color=color)
            else:
                fig = fallback_table(df)

        elif chart_type in {"pie", "donut"}:
            labels = chart_config.get("labels", {}).get("standard")
            values = chart_config.get("values", {}).get("standard")
            if not labels or not values:
                return [fallback_table(df)]
            fig = px.pie(df, names=labels, values=values, hole=0.4 if chart_type == "donut" else 0)

        else:
            fig = fallback_table(df)

    except Exception as e:
        print(f"⚠️ Failed to plot {chart_type}: {e}")
        fig = fallback_table(df)

    figs.append(fig)
    return figs












prompt = f"""
You are a data visualization assistant helping unify result sets from multiple databases.

The user question is:
{question}

Below are result columns returned from each database (not SQL):

{description_section}

Your tasks:
1. Understand the semantic meaning of each column in each DB.
2. Suggest the most appropriate chart type for the user question and the available columns.
3. If each database returns a **single aggregated value** (like COUNT or SUM), suggest a **pie** or **donut** chart. In this case:
   - Use `"labels"` as the database name (e.g., `"eon"`, `"swift"`).
   - Use `"values"` as the actual aggregate column (e.g., `"total_orders"`).
   - Example:
     {{
       "chart_type": "pie",
       "labels": {{
         "standard": "database"
       }},
       "values": {{
         "standard": "total_orders",
         "eon": "total_orders",
         "swift": "COUNT(*)",
         "pipeline": "COUNT(order_id)"
       }}
     }}
4. If the results have **multiple rows per database** (like per-product, per-date), suggest a **bar**, **line**, or **scatter** chart:
   - Provide `x_axis` and `y_axis` mappings for each DB.
   - Example:
     {{
       "chart_type": "bar",
       "x_axis": {{
         "standard": "product",
         "eon": "product_name",
         "swift": "item"
       }},
       "y_axis": {{
         "standard": "total_sales",
         "eon": "order_qty",
         "swift": "units_sold"
       }},
       "group_by": "database"
     }}
5. Do **not** use database names (like `"eon"` or `"swift"`) as column names. Use `"database"` as a virtual label only if needed.
6. Always return your response in a valid JSON format matching one of the above examples.
"""





def normalize_and_merge_results(all_results: List[Dict[str, Any]], chart_mapping: Dict[str, Any]) -> pd.DataFrame:
    frames = []
    chart_type = chart_mapping.get("chart_type", "").lower()

    if chart_type in {"pie", "donut"}:
        label_std = chart_mapping.get("labels", {}).get("standard")
        value_std = chart_mapping.get("values", {}).get("standard")
        if not label_std or not value_std:
            return pd.DataFrame()
    else:
        x_std = chart_mapping.get("x_axis", {}).get("standard")
        y_std = chart_mapping.get("y_axis", {}).get("standard")
        if not x_std or not y_std:
            return pd.DataFrame()

    for result in all_results:
        db_key = result["db"]
        rows = result["results"]
        if not rows:
            continue

        df = pd.DataFrame(rows)

        if chart_type in {"pie", "donut"}:
            label_map = chart_mapping.get("labels", {}).get(db_key)
            value_map = chart_mapping.get("values", {}).get(db_key)

            # ✅ Fix: if label is "database", inject it manually
            if label_std == "database":
                df[label_std] = db_key
            elif not label_map or label_map not in df.columns:
                continue
            else:
                df = df.rename(columns={label_map: label_std})

            if not value_map or value_map not in df.columns:
                df[value_std] = 1
            else:
                df = df.rename(columns={value_map: value_std})

            df["database"] = db_key  # Always include for traceability
            frames.append(df[[label_std, value_std, "database"]])

        else:
            x_map = chart_mapping.get("x_axis", {}).get(db_key)
            y_map = chart_mapping.get("y_axis", {}).get(db_key)

            if not x_map or x_map not in df.columns:
                continue

            df = df.rename(columns={x_map: x_std})
            if not y_map or y_map not in df.columns:
                df[y_std] = 1
            else:
                df = df.rename(columns={y_map: y_std})

            df["database"] = db_key
            frames.append(df[[x_std, y_std, "database"]])

    return pd.concat(frames, ignore_index=True) if frames else pd.DataFrame()














if chart_type in {"pie", "donut"}:
    label_map = chart_mapping.get("labels", {}).get(db_key)
    value_map = chart_mapping.get("values", {}).get(db_key)

    if label_std == "database":
        df[label_std] = db_key
    elif not label_map or label_map not in df.columns:
        continue
    else:
        df = df.rename(columns={label_map: label_std})

    if not value_map or value_map not in df.columns:
        df[value_std] = 1
    else:
        df = df.rename(columns={value_map: value_std})

    # Only include "database" if not already the label column
    if label_std == "database":
        frames.append(df[[label_std, value_std]])
    else:
        df["database"] = db_key
        frames.append(df[[label_std, value_std, "database"]])

























def normalize_and_merge_results(all_results: List[Dict[str, Any]], chart_mapping: Dict[str, Any]) -> pd.DataFrame:
    frames = []
    chart_type = chart_mapping.get("chart_type", "").lower()

    if chart_type in {"pie", "donut"}:
        label_std = chart_mapping.get("labels", {}).get("standard")
        value_std = chart_mapping.get("values", {}).get("standard")
        if not label_std or not value_std:
            return pd.DataFrame()
    else:
        x_std = chart_mapping.get("x_axis", {}).get("standard")
        y_std = chart_mapping.get("y_axis", {}).get("standard")
        if not x_std or not y_std:
            return pd.DataFrame()

    for result in all_results:
        db_key = result["db"]
        rows = result["results"]
        if not rows:
            continue

        df = pd.DataFrame(rows)

        if chart_type in {"pie", "donut"}:
            label_map = chart_mapping.get("labels", {}).get(db_key)
            value_map = chart_mapping.get("values", {}).get(db_key)

            if label_std == "database":
                df[label_std] = db_key
            elif not label_map or label_map not in df.columns:
                continue
            else:
                df = df.rename(columns={label_map: label_std})

            if not value_map or value_map not in df.columns:
                df[value_std] = 1
            else:
                df = df.rename(columns={value_map: value_std})

            # ✅ Only include "database" column once
            if label_std == "database":
                frames.append(df[[label_std, value_std]])
            else:
                df["database"] = db_key
                frames.append(df[[label_std, value_std, "database"]])

        else:
            x_map = chart_mapping.get("x_axis", {}).get(db_key)
            y_map = chart_mapping.get("y_axis", {}).get(db_key)

            if not x_map or x_map not in df.columns:
                continue

            df = df.rename(columns={x_map: x_std})
            if not y_map or y_map not in df.columns:
                df[y_std] = 1
            else:
                df = df.rename(columns={y_map: y_std})

            df["database"] = db_key
            frames.append(df[[x_std, y_std, "database"]])

    return pd.concat(frames, ignore_index=True) if frames else pd.DataFrame()


















-----------------------
-----------------------


import pandas as pd
from typing import List, Dict, Any

def normalize_and_merge_results(all_results: List[Dict[str, Any]], chart_mapping: Dict[str, Any]) -> pd.DataFrame:
    frames = []
    chart_type = chart_mapping.get("chart_type", "").lower()

    # Extract standard column names
    if chart_type in {"pie", "donut"}:
        label_std = chart_mapping.get("labels", {}).get("standard")
        value_std = chart_mapping.get("values", {}).get("standard")
        if not label_std or not value_std:
            return pd.DataFrame()
    else:
        x_std = chart_mapping.get("x_axis", {}).get("standard")
        y_std = chart_mapping.get("y_axis", {}).get("standard")
        if not x_std or not y_std:
            return pd.DataFrame()

    for result in all_results:
        db_key = result["db"]
        rows = result["results"]
        if not rows:
            continue

        df = pd.DataFrame(rows)

        if chart_type in {"pie", "donut"}:
            label_map = chart_mapping.get("labels", {}).get(db_key)
            value_map = chart_mapping.get("values", {}).get(db_key)

            if label_std == "database":
                df[label_std] = db_key
            elif not label_map or label_map not in df.columns:
                print(f"⚠️ Skipping {db_key}: label column '{label_map}' missing")
                continue
            else:
                df = df.rename(columns={label_map: label_std})

            if not value_map or value_map not in df.columns:
                print(f"⚠️ Value column '{value_map}' not found in {db_key}, using fallback = 1")
                df[value_std] = 1
            else:
                df = df.rename(columns={value_map: value_std})

            if label_std == "database":
                frames.append(df[[label_std, value_std]])
            else:
                df["database"] = db_key
                frames.append(df[[label_std, value_std, "database"]])

        else:
            x_map = chart_mapping.get("x_axis", {}).get(db_key)
            y_map = chart_mapping.get("y_axis", {}).get(db_key)

            if not x_map or x_map not in df.columns:
                print(f"⚠️ Skipping {db_key}: x-axis column '{x_map}' not in result")
                continue

            df = df.rename(columns={x_map: x_std})

            if not y_map or y_map not in df.columns:
                print(f"⚠️ y-axis column '{y_map}' not found in {db_key}, using fallback value 1")
                df[y_std] = 1
            else:
                df = df.rename(columns={y_map: y_std})

            df["database"] = db_key

            # ✅ Final defensive check to avoid KeyError
            missing_cols = [col for col in [x_std, y_std, "database"] if col not in df.columns]
            if missing_cols:
                print(f"⚠️ Skipping {db_key}: missing columns {missing_cols}")
                continue

            frames.append(df[[x_std, y_std, "database"]])

    return pd.concat(frames, ignore_index=True) if frames else pd.DataFrame()


